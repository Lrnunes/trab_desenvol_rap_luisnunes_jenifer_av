# trab_desenvol_rap_luisnunes_jenifer
 Implementação de Rad com Banco De Dados em Python Jenifer Carvalho/Luis Roberto Nunes  Introdução  Cada vez mais, nós geramos e consumimos dados para poder realizar atividades que vão desde a abertura de uma conta bancária, até as informações que disponibilizamos nas redes sociais.Portanto, é necessário entender como esses dados são gerenciados, pois são importantes para identiﬁcar pessoas, preferências, produtos, transações ﬁnanceiras, entre tantas outras aplicações.Para fazer esse gerenciamento, as aplicações fazem uso de sistemas gerenciadores de banco de dados, demodo a tornar possível a realização de operações de inserção, consulta, alteração e exclusão de dados. Além disso, para que o usuário possa interagir de modo eﬁciente com o sistema, é importante que ele tenha à disposição uma interface gráﬁca que facilite o seu acesso às funcionalidades implementadas. Nesse sentido, a linguagem Python aparece como uma opção muito eﬁcaz para atingir esses objetivos, uma vez que oferece recursos para desenvolver aplicações que integrem interface gráﬁca com operações no banco de dados. Ao longo deste trabalho, apresentaremos alguns frameworks e bibliotecas para desenvolver aplicações de interface gráﬁca, além de explorarmos como realizar aplicações no banco de dados. Tambem veremos o cadastro, exclusão e atualização de produtos feito atraves do PostgreSQL e Pycharm junto com a metodologia Rad. Que segundo Martin(1991)1,a metodologia RAD possui quatros fases distintas(Que veremos ao longo do trabalho),que são: 1. Fase de planejamento de requisitos:  Trata das necessidades de negócios,  escopo do projeto, restrições e requisitos do sistema. 2. Fase de design do usuário  Nessa fase, são desenvolvidos modelos e protótipos para representar todos os processos, entradas e saídas do sistema. 3. Fase de construção: É nesta fase que os protótipos são desenvolvidos. 4. Fase de transição: Aqui, são feitos processamento de dados, testes, mudança para o novo sistema e treinamento do usuário.  Veremos essas fases ao longo do trabalho 2. Aplicando a Metodologia RAD 2.1 Fase de Planejamento dos Requisitos Nessa etapa, deverá ser elaborado os principais requisitos do seu sistema. Aqui também devem estar elencados o caso de uso, a modelagem de dados e a modelagem de negócios do seu sistema. Não esqueça de descrever o propósito e os requisitos funcionais do seu sistema. Criar uma tabela de inserção, atualização e exclusão de produto dentro do BD, com frameworks e widgets para auxiliar em sua criação. Por exemplo: O Tkinter é o framework GUI padrão do Python. Sua sintaxe é simples, possui muitos componentes para interação com o usuário. Além disso, seu código é aberto e é disponível sob a licença Python. E que possui diversos componentes (widgets), tais como botões, rótulos e caixas de texto usados para criar aplicações interativas com o usuário. O GUI é considerada a padrão para desenvolvimento de interface gráfica no Python. Ela fornece uma interface orientada a objetos que facilita a implementação de programas interativos e iremos utilizar ela em nosso trabalho. PostgreSQL  é utilizado para gerenciar os nossos dados. O PostgreSQL é um sistema gerenciador de banco de dados de licença gratuita e é considerado bastante robusto para aplicações de um modo geral. Através da ferramenta pgAdmin, podemos e vamos criar a tabela produto. Uma boa forma de iniciar o projeto é inserindo dados aleatórios na tabela. Para isso, vamos usar o pacote “faker”, que é bastante útil para gerar dados aleatórios. Apresentaremos a parte do sistema responsável pelas operações CRUD. O sistema foi desenvolvido usando programação orientada a objetos. Vamos apresentar a parte do sistema responsável pela interação com o usuário através de uma interface gráfica. Do mesmo modo que a classe “AppBD”, esse programa também foi desenvolvido em programação orientada a objetos. A classe com os atributos e métodos para trabalhar com a interface gráfica e interagir com a classe responsável pelas operações com o banco de dados é a “PrincipalBD”. A RAD faz uso de ferramentas de desenvolvimento que padronizam a implementação dos sistemas e apoiam os desenvolvedores na implementação de interfaces gráficas com o usuário, manipulação de dados, desenvolvimentos de APIs e outros serviços que poupam o tempo do desenvolvedor, para que possa usá-lo de forma mais eficiente para a implementação do sistema.  O sistema foi implementado para ser de facil manipulação pelo usuario, e com isso ser simples e rapido. 2.2 Fase de Design Cadastro de produtos no banco de dados feita atraves da  IDE       2.3 Fase de Construção Essa etapa é relativa à construção do seu sistema. Descreva aqui as principais implementações do seu projeto. class PrincipalBD: utilizada para criar o escopo da tela def fLer(self): utilizado para conseguirmos ler os dados do BD def fLimparTela(self): utilizado para limpar os dados depois do cadastro no BD def fCadastrarProduto(self): utilizado para conseguirmos cadastrar os produtos no BD def fAtualizarProduto(self):utilizado para conseguirmos atualizar os produtos no BD def fExcluirProduto(self):utilizado para excluir o produto no BD from faker import Faker: utilizador para cadastro automatico de produtos fakes  import psycopg2: utilizado para acessar o banco ataves da IDE conn = psycopg2.connect(database="postgres", user="postgres", password="Estacio@123", port="5432"): utilizado para ajudar a conectar com o BD  cur = conn.cursor() // cur.execute // conn.commit() // conn.close(): utilizados para conseguir acessar, executar e finalizar a conexão componentes do PrincipalBD: usados no auxilio da criação da janela. exemplo: self.lblPreco = tk.Label(win, text='Preço ')         self.txtCodigo = tk.Entry(bd=3) self.lblNome.place(x=100, y=100)        self.txtNome.place(x=250, y=100)   2.4 Fase de Testes PRINCIPAL # coding=utf-8 import tkinter as tk from tkinter import ttk import crud as crud   class PrincipalBD:     def __init__(self, win):         self.objBD = crud.AppBD()         # componentes         self.lbCodigo = tk.Label(win, text='Codigo do produto: ')         self.lblNome = tk.Label(win, text='Nome do produto ')         self.lblPreco = tk.Label(win, text='Preço ')          self.txtCodigo = tk.Entry(bd=3)         self.txtNome = tk.Entry()         self.txtPreco = tk.Entry()          self.btnCadastrar = tk.Button(win, text='Cadastrar', command=self.fCadastrarProduto)         self.btnAtualizar = tk.Button(win, text='Atualizar', command=self.fAtualizarProduto)         self.btnExcluir = tk.Button(win, text='Excluir', command=self.fExcluirProduto)         self.btnLimpar = tk.Button(win, text='Limpar', command=self.fLimparTela)          #componentes da treeview         self.dadosColunas =("Código", "Nome", "Preço")         self.treeProdutos = ttk.Treeview(win, columns=self.dadosColunas,                                          selectmode='browse')         self.verscrlbar =ttk.Scrollbar(win, orient="vertical",                                        command=self.treeProdutos.yview())         self.verscrlbar.pack(side = 'right', fill = 'x')         self.treeProdutos.configure(yscrollcommand=self.verscrlbar.set)          self.treeProdutos.heading("Código", text="Código")         self.treeProdutos.heading("Nome", text="Nome")         self.treeProdutos.heading("Preço", text="Preço")          self.treeProdutos.column("Código",minwidth = 0, width=100)         self.treeProdutos.column("Nome", minwidth=0, width=100)         self.treeProdutos.column("Preço", minwidth=0, width=100)          self.treeProdutos.pack(padx=10, pady= 10)         self.treeProdutos.bind("<< TreeviewSelect >>",                                self.apresentarRegistrosSelecionados)           self.lbCodigo.place(x=100, y=50)         self.txtCodigo.place(x=250, y=50)          self.lblNome.place(x=100, y=100)         self.txtNome.place(x=250, y=100)          self.lblPreco.place(x=100, y=150)         self.txtPreco.place(x=250, y=150)          self.btnCadastrar.place(x=100, y=200)         self.btnAtualizar.place(x=200, y=200)         self.btnExcluir.place(x=300, y=200)         self.btnLimpar.place(x=400, y=200)          self.treeProdutos.place(x=100, y=300)         self.verscrlbar.place(x=805, y=300, height=225)         self.carregarDadosIniciais()      def fLer(self):         try:             codigo = int(self.txtCodigo.get())             print('codigo', codigo)             nome = self.txtNome.get()             print('nome', nome)             preco = float(self.txtPreco.get())             print('preco', preco)             print('Leitura dos Dados feita!!')         except:             print('Não foi possivel ler os dados.')             return codigo, nome, preco      def fLimparTela(self):         try:             self.txtCodigo.delete(0, tk.END)             self.txtNome.delete(0, tk.END)             self.txtPreco.delete(0, tk.END)             print("Limpo!")         except:             print("Não foi possivel limpar.")      def fCadastrarProduto(self):         try:             codigo, nome, preco = self.fLer()             self.objBD.inserirDados(codigo, nome, preco)             self.treeProdutos.insert(' ', 'end',                                          iid=self.iid,                                          values=(codigo, nome, preco))             self.iid=self.iid+1             self.id = self.id+1             self.fLimparTela()             print("Produto cadastrado!")         except:             print("Não foi possivel fazer o cadastro.")      def fAtualizarProduto(self):         try:             codigo, nome, preco = self.fLer()             self.objBD.atualizarDados(codigo, nome, preco)             self.carregarDadosIniciais()             self.fLimparTela()             self.fake()             print("Produto atualizado!!")         except:             print("Não foi possivel atualizar o produto.")      def fExcluirProduto(self):         try:             codigo, nome, preco = self.fLer()             self.objBD.excluirDados(codigo)             self.carregarDadosIniciais()             self.fLimparTela()             print("Produto excluido!!")         except:             print("Não foi possivel excluir o produto")     def apresentarRegistrosSelecionados(self, event):         self.fLimparTela()         for selection in self.treeProdutos.selection():             item = self.treeProdutos.item(selection)             codigo, nome, preco = item["values"][0:3]             self.txtCodigo.insert(0, codigo)             self.txtNome.insert(0, nome)             self.txtPreco.insert(0, preco)  # carregar dados iniciais     def carregarDadosIniciais(self):         try:             self.id = 0             self.iid = 0             registro = self.objBD.selecionarDados()             print("Dados disponiveis no BD")             for item in registro:                 codigo = item[0]                 nome = item[1]                 preco = item[2]                 print("Codigo = ", codigo)                 print("Nome = ", nome)                 print("Preço", preco)                  self.treeProdutos.insert(' ', 'end',                                             iid=self.iid,                                             values=(codigo, nome, preco))                 self.iid = self.iid + 1                 self.id = self.id + 1                 print("Dados da base")         except:             print("Ainda não existem dados para carregar!")  janela = tk.Tk() principal = PrincipalBD(janela) janela.title('Bem vindo(a) a tela de cadastro') janela.geometry("500x500+20+10") janela.mainloop()   CRUD # coding=utf-8 from faker import Faker import psycopg2   class AppBD:     def __init__(self):          print('Método Construtor')      def abrirConexao(self):         try:             self.connection = psycopg2.connect(user="postgres", password="Estacio@123",                                                host="127.0.0.1", port="5432", database="postgres")         except (Exception, psycopg2.Error) as error:             if (self.connection):                 print("Falha ao se conectar ao Banco de Dados", error)      # inserir dados     def inserirDados(self, codigo, nome, preco):         try:             self.abrirConexao()             cur = self.connection.cursor()             postgres_insert_query = """ INSERT INTO public. "PRODUTO"             ("CODIGO", "NOME", "PRECO") VALUES (%s, %s, %s) """             record_to_insert = (codigo, nome, preco)             cur.execute(postgres_insert_query, record_to_insert)             self.connection.commit()             count = cur.rowcount             print(count, "Registro inserido na Tabela ")         except (Exception, psycopg2.Error) as error:             if (self.connection) :                 print("Falha ao inserir na Tabela", error)         finally:             # closing database connection.             if (self.connection) :                 cur.close()                 self.connection.close()                 print("A conexão com o PostgreSQL foi encerrada!!")      # atualizar dados     def atualizarDados(self, codigo, nome, preco):         try:             self.abrirConexao()             cur = self.connection.cursor()             sql_update_query = """ Update puclic."PRODUTO" set "NOME" = %s,              "PRECO" = %s where "CODIGO" = %s """             cur.execute(sql_update_query, (nome, preco, codigo))             self.connection.commit()             cont = cur.rowcount             print(cont, "Registro atualizado!! ")             print("Registro depois da atualização ")             sql_select_query = """Select *from public. "PRODUTO"              where "CODIGO" = %s """             cur.execute(sql_select_query, codigo)             record = cur.fetchone()             print(record)         except (Exception, psycopg2.Error) as error:             print("Erro na atualização", error)         finally:             # clossing database connection.             if (self.connection) :                 cur.close()                 self.connection.close()                 print("A conexão com o PostgreSQL foi encerrada.")      # excluir dados     def excluirDados(self, codigo):         try:             self.abrirConexao()             cursor = self.connection.cursor()             sql_delete_query = """ Delete from public. "PRODUTO"             where "CODIGO" = %s """             cursor.execute(sql_delete_query, codigo)             self.connection.commit()             cont = cur.rowcount             print(cont, "Registro excluido!!")         except(Exception, psycopg2.Error) as error:             print("Erro na exclusão", error)         finally:             # clossing database connection.             if (self.connection):                 cur.close()                 self.connection.close()                 print("A conexão com o PostgreSQL foi encerrada.")  # criando e conectando com o BD conn = psycopg2.connect(database="postgres", user="postgres", password="Estacio@123", port="5432") print("Conexão com o Banco de Dados aberta!!")  cur = conn.cursor() cur.execute(""" CREATE TABLE PRODUTO                 (CODIGO INT PRIMARY KEY NOT NULL,                 NOME TEXT NOT NULL,                 PRECO REAL NOT NULL);                                    """) print("Tabela criada no BD!!") conn.commit() conn.close()  # inserindo dados na tabela conn = psycopg2.connect(database="postgres", user="postgres", password="Estacio@123", port="5432") print("Conexão com o Banco de Dados aberta!!")  cur = conn.cursor() fake = Faker('pt_BR')  n=10 for i in range(n):     codigo = i+10     nome = 'produto_'+str(i+1)     preco = fake.pyfloat(left_digits=3, right_digits=2, positive=True, min_value=5, max_value=1000)     print(codigo)     print(nome)     print(preco) comandoSQL = """INSERT INTO public. PRODUTO (CODIGO, NOME, PRECO)                 VALUES (%s, %s, %s)                 """ registro = codigo, nome, preco cur.execute(comandoSQL, registro) conn.commit() print("Inserção realizada!!!") conn.close()  # selecionando dados na tabela conn = psycopg2.connect(database="postgres", user="postgres", password="Estacio@123", port="5432")  cur = conn.cursor() cur.execute(""" SELECT * FROM PRODUTO where codigo = 2 """) registro = cur.fetchone() print("Dados encontrados ->") conn.commit() print("Seleção realizada!!!")  # atualizando dados na tabela conn = psycopg2.connect(database="postgres", user="postgres", password="Estacio@123", port="5432")  cur = conn.cursor() cur.execute(""" SELECT *FROM PRODUTO where codigo = 1 """) registro = cur.fetchone() print(registro) cur.execute(""" UPDATE PRODUTO set PRECO = 96385471 where codigo = 1""") conn.commit() print("Registro Atualizado!!! ") cur = conn.cursor() print("--- Consulta após a atualização ---") cur.execute(""" SELECT *FROM PRODUTO where codigo = 1 """) registro = cur.fetchone() print("Dados atualizados ->", registro) conn.commit() conn.close()  # excluindo dados na tabela conn = psycopg2.connect(database="postgres", user="postgres", password="Estacio@123", port="5432")  cur = conn.cursor() cur.execute(""" DELETE FROM PRODUTO where codigo = 1 """) conn.commit() count = cur.rowcount  print(count, "-> Registro excluido!") print("Exclusão realizada!!!") conn.close() •	Conclusão O Python é uma linguagem muito bem documentada e utilizamos algumas bibliotecas na criação do projeto, mas existem muitas outras. A escolha de uma delas deve levar em consideração questões como tempo para desenvolvimento, maturidade do programador e quais os recursos computacionais que se têm à disposição. O projeto foi feito para ser algo simples e que funcione de acordo com o que promove, no caso um simples cadastro de forma facil e acesso ao BD atraves da IDE.   •	Referências Bibliográficas Sala de aula Virtual --- Interface gráfica com Python Sala de aula Virtual --- Aplicando Rad
